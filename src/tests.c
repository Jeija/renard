#include <stdbool.h>
#include <assert.h>
#include <stdio.h>

#include "sigfox_mac.h"
#include "sigfox_crc.h"
#include "downlink.h"

/*** Inputs / outputs for CRC16 function testing ***/
uint8_t crc16_input1[] = {
	0x40, 0xbd, 0xdb, 0x33, 0x4d, 0x00, 0x48, 0x65, 0x6c, 0x6c,
	0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0xf4, 0x2e, 0xb4
};
uint16_t crc16_output1 = 0x32c0;

uint8_t crc16_input2[] = {
	0x40, 0xce, 0xdb, 0x33, 0x4d, 0x00, 0x48, 0x65, 0x6c, 0x6c,
	0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x2f, 0x4c, 0x1e
};
uint16_t crc16_output2 = 0x3dde; 

uint8_t crc16_input3[] = {
	0x40, 0xbb, 0xdb, 0x33, 0x4d, 0x00, 0x48, 0x65, 0x6c, 0x6c,
	0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x41, 0x70, 0x81
};
uint16_t crc16_output3 = 0x8889; 

uint8_t crc16_input4[] = {
	0x40, 0xd0, 0xdb, 0x33, 0x4d, 0x00, 0x48, 0x65, 0x6c, 0x6c,
	0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x39, 0x6c, 0xaa
};
uint16_t crc16_output4 = 0x69c7;

uint8_t crc16_inputlen = 20;

/*** Inputs / Outputs for CRC8 function testing ***/
uint8_t crc8_input1[] = {
	0xde, 0xad, 0xbe, 0xef, 0xde,
	0xad, 0xbe, 0xef, 0x97, 0x3c
};
uint8_t crc8_output1 = 0xf2;

uint8_t crc8_input2[] = {
	0xde, 0xad, 0xbe, 0xef, 0xde,
	0xad, 0xbe, 0xef, 0xad, 0xa0
};
uint8_t crc8_output2 = 0x43;

uint8_t crc8_inputlen = 10;

/*** Inputs / outputs for MAC / AES function testing ***/
#define USE_PUBLIC_KEY 0

// Private key of my sigfox device that matches the given
// mac input and output
uint8_t private_key_in[] = {
	0x47, 0x9e, 0x44, 0x80, 0xfd, 0x75, 0x96, 0xd4,
	0x5b, 0x01, 0x22, 0xfd, 0x28, 0x2d, 0xb3, 0xcf
};

/*uint8_t public_key[] = {
	0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
};*/

#define MAC1_LEN 32
uint8_t mac1_in[] = {
	0x40, 0xd1, 0xdb, 0x33, 0x4d, 0x00, 0x48, 0x65,
	0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c,
	0x64, 0x40, 0xd1, 0xdb, 0x33, 0x4d, 0x00, 0x48,
	0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72
};

uint8_t mac1_out[] = {
	0xb0, 0x01, 0x8c, 0x16, 0xde, 0x40, 0x82, 0xd7,
	0xc3, 0x8f, 0xc5, 0x22, 0xe6, 0xae, 0x93, 0x94,
	0x2d, 0xd0, 0xa9, 0xaa, 0xb9, 0xb5, 0x9e, 0x4a,
	0xc6, 0x96, 0x32, 0x4f, 0x1f, 0x57, 0x63, 0x9c
};

/*** Inputs / outputs for downlink decoding testing ***/
#define DOWNLINK_PAYLOAD_LEN 8
sfx_dl_encoded dl_to_decode1_in = {
	.frame = {
		0xca, 0x2e, 0xf5, 0x2c, 0x82, 0x72, 0x81, 0xa9,
		0x43, 0xa4, 0xa7, 0xea, 0x76, 0x48, 0x7c
	}
};

sfx_commoninfo dl_to_decode1_common_in = {
	.seqnum = 0x16b,
	.devid = 0x004d33db,
	.key = {
		0x47, 0x9e, 0x44, 0x80, 0xfd, 0x75, 0x96, 0xd4,
		0x5b, 0x01, 0x22, 0xfd, 0x28, 0x2d, 0xb3, 0xcf
	}
};

sfx_dl_plain dl_to_decode1_out = {
	.payload = {
		0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef
	},
	.crc_ok = true,
	.mac_ok = true
};

/*** Inputs / outputs for downlink decoding testing *with error correction* ***/
sfx_dl_encoded dl_to_decode2_in = {
	.frame = {
		/* original without errors:
		 * 0xe0, 0xe7, 0x8f, 0x50, 0x5f, 0x33, 0xfd, 0xdd,
		 * 0xa7, 0x82, 0x99, 0xb4, 0x96, 0x79, 0xc1
		 */
		0xe0, 0xe7, 0x8f, 0x50, 0x7f, 0x33, 0xfd, 0xdd,
		0xa7, 0x82, 0x99, 0xb4, 0x99, 0x79, 0xc1
	}
};

sfx_commoninfo dl_to_decode2_common_in = {
	.seqnum = 0x146,
	.devid = 0x004d33db,
	.key = {
		0x47, 0x9e, 0x44, 0x80, 0xfd, 0x75, 0x96, 0xd4,
		0x5b, 0x01, 0x22, 0xfd, 0x28, 0x2d, 0xb3, 0xcf
	}
};

sfx_dl_plain dl_to_decode2_out = {
	.payload = {
		0x00, 0x00, 0x33, 0x0d, 0x00, 0x00, 0xff, 0xc5
	},
	.crc_ok = true,
	.mac_ok = true
};

void tests() {
	printf("Reverse Engineered Sigfox Stack - Running basic tests\n");
	printf("CRC16 assertions...\n");
	assert(SIGFOX_CRC_crc16(crc16_input1, crc16_inputlen) == crc16_output1);
	assert(SIGFOX_CRC_crc16(crc16_input2, crc16_inputlen) == crc16_output2);
	assert(SIGFOX_CRC_crc16(crc16_input3, crc16_inputlen) == crc16_output3);
	assert(SIGFOX_CRC_crc16(crc16_input4, crc16_inputlen) == crc16_output4);
	printf("CRC16 assertions succeeded\n");

	printf("CRC8 assertions...\n");
	assert(SIGFOX_CRC_crc8(crc8_input1, crc8_inputlen) == crc8_output1);
	assert(SIGFOX_CRC_crc8(crc8_input2, crc8_inputlen) == crc8_output2);
	printf("CRC8 assertions succeeded\n");

	printf("MAC assertions...\n");
	uint8_t mac1_encrypted[MAC1_LEN];
	aes_128_cbc_encrypt(mac1_encrypted, mac1_in, MAC1_LEN, private_key_in);
	for (uint8_t i = 0; i < MAC1_LEN; ++i)
		assert(mac1_encrypted[i] == mac1_out[i]);
	printf("MAC assertions succeeded\n");

	printf("Downlink decode assertions...\n");
	sfx_dl_plain dl_to_decode1_decoded;
	sfx_downlink_decode(dl_to_decode1_in, dl_to_decode1_common_in, &dl_to_decode1_decoded);
	assert(dl_to_decode1_out.crc_ok == dl_to_decode1_decoded.crc_ok);
	assert(dl_to_decode1_out.mac_ok == dl_to_decode1_decoded.mac_ok);
	for (uint8_t i = 0; i < DOWNLINK_PAYLOAD_LEN; ++i)
		assert(dl_to_decode1_out.payload[i] == dl_to_decode1_decoded.payload[i]);
	printf("Downlink decode assertions succeeded\n");

	printf("Downlink decode with error correction assertions...\n");
	sfx_dl_plain dl_to_decode2_decoded;
	sfx_downlink_decode(dl_to_decode2_in, dl_to_decode2_common_in, &dl_to_decode2_decoded);
	assert(dl_to_decode2_out.crc_ok == dl_to_decode2_decoded.crc_ok);
	assert(dl_to_decode2_out.mac_ok == dl_to_decode2_decoded.mac_ok);
	for (uint8_t i = 0; i < DOWNLINK_PAYLOAD_LEN; ++i)
		assert(dl_to_decode2_out.payload[i] == dl_to_decode2_decoded.payload[i]);
	printf("Downlink decode with error correction assertions succeeded\n");
}
